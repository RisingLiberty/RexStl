// ============================================ 
//
// REX - BUILD SYSTEM
//
// Author: Nick De Breuck
// Twitter: @nick_debreuck
// 
// File: main.sharpmake.cs
// Copyright (c) Nick De Breuck 2022
//
// ============================================

using System.IO;
using System.Linq;
using Sharpmake;
using System;
using System.Collections.Generic;

[module: Sharpmake.Include("globals.sharpmake.cs")]
[module: Sharpmake.Include("target.sharpmake.cs")]
[module: Sharpmake.Include("config.sharpmake.cs")]

// Represents the project that will be generated by Sharpmake and that contains
// the sample C++ code.
public class BaseProject : Project
{
  public BaseProject() : base(typeof(RexTarget), typeof(RexConfiguration))
  {
  }

  [Configure]
  public virtual void Configure(RexConfiguration conf, RexTarget target)
  {
    conf.Name = target.Config.ToString().ToLower();
    conf.ProjectPath = Path.Combine(Globals.Root, ".rex", "build", target.DevEnv.ToString(), Name);
    conf.IntermediatePath = Path.Combine(conf.ProjectPath, "intermediate", conf.Name, target.Compiler.ToString());
    conf.TargetPath = Path.Combine(conf.ProjectPath, "bin", conf.Name);
    conf.UseRelativePdbPath = false;
    conf.LinkerPdbFilePath = Path.Combine(conf.TargetPath, $"{Name}_{conf.Name}_{target.Compiler}{conf.LinkerPdbSuffix}.pdb");
    conf.CompilerPdbFilePath = Path.Combine(conf.TargetPath, $"{Name}_{conf.Name}_{target.Compiler}{conf.CompilerPdbSuffix}.pdb");

    if (target.Compiler == Compiler.MSVC)
    {
      conf.IncludeSystemPaths.Add(@"D:\Tools\Windows SDK\10.0.19041.0\include\um");
      conf.IncludeSystemPaths.Add(@"D:\Tools\Windows SDK\10.0.19041.0\include\shared");
      conf.IncludeSystemPaths.Add(@"D:\Tools\Windows SDK\10.0.19041.0\include\winrt");
      conf.IncludeSystemPaths.Add(@"D:\Tools\Windows SDK\10.0.19041.0\include\cppwinrt");
      conf.IncludeSystemPaths.Add(@"D:\Tools\Windows SDK\10.0.19041.0\include\ucrt");
      conf.IncludeSystemPaths.Add(@"D:\Tools\MSVC\install\14.29.30133\include");
      conf.IncludeSystemPaths.Add(@"D:\Tools\MSVC\install\14.29.30133\atlmfc\include");
    }

    if (target.Compiler == Compiler.GCC && conf.Output == Configuration.OutputType.Dll) // Sharpmake doesn't support DLLs for GCC
    {
      conf.Output = Configuration.OutputType.Lib;
    }

    conf.IncludePaths.Add($@"{SourceRootPath}\include");

    string postbuildCommandScript = Path.Combine(Globals.Root, "build", "scripts", $"post_build.py -p={Name} -comp={target.Compiler} -conf={conf.Name}");

    conf.EventPostBuild.Add(postbuildCommandScript);

    conf.disable_exceptions();

    conf.use_general_options();
    conf.use_compiler_options();
    conf.use_linker_options();

    if (target.DevEnv == DevEnv.vs2019)
    {
      conf.add_dependency<SharpmakeProject>(target);
    }

    switch (target.Optimization)
    {
      case Optimization.NoOpt:
        conf.Options.Add(Options.Vc.General.DebugInformation.ProgramDatabase);
        conf.disable_optimization();
        break;
      case Optimization.FullOptWithPdb:
        conf.Options.Add(Options.Vc.General.DebugInformation.ProgramDatabase);
        conf.enable_optimization();
        conf.Options.Add(Options.Vc.Linker.LinkTimeCodeGeneration.Default);      // To fix linker warning
        conf.Options.Add(Options.Vc.Compiler.OmitFramePointers.Disable);         // Disable so we can have a stack trace
        break;
      case Optimization.FullOpt:
        conf.Options.Add(Options.Vc.General.DebugInformation.Disable);
        conf.Options.Add(Options.Vc.General.WholeProgramOptimization.Optimize);
        conf.enable_optimization();
        break;
    }

    switch (target.Platform)
    {
      case Platform.win32:
      case Platform.win64:
        conf.add_public_define("REX_PLATFORM_WINDOWS");
        break;
      default:
        break;
    }
  }

}

// The sharpmake project that generates the solution
// It makes life a lot easier if this is directly in the solution.
[Generate]
public class SharpmakeProject : CSharpProject
{
  public SharpmakeProject() : base(typeof(RexTarget), typeof(RexConfiguration))
  {
    SourceRootPath = "[project.SharpmakeCsPath]";

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);
    //RexTarget ninjaTarget = new RexTarget(Platform.win64, DevEnv.ninja, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC | Compiler.Clang);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget);
  }

  [Configure()]
  public virtual void ConfigureAll(RexConfiguration conf, RexTarget target)
  {
    conf.ProjectPath = Path.Combine(Globals.Root, ".rex", "build", target.DevEnv.ToString(), Name);
    conf.IntermediatePath = Path.Combine(conf.ProjectPath, "intermediate", conf.Name, target.Compiler.ToString());
    conf.TargetPath = Path.Combine(conf.ProjectPath, "bin", conf.Name);
    conf.Output = Configuration.OutputType.DotNetClassLibrary;
    conf.StartWorkingDirectory = Globals.SharpmakeRoot;

    string sharpmakeAppPath = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;
    string sharpmakeDllPath = Path.Combine(Path.GetDirectoryName(sharpmakeAppPath), "sharpmake.dll");

    conf.ReferencesByPath.Add(sharpmakeDllPath);
    conf.ReferencesByName.AddRange(new Strings("System",
                                               "System.Core",
                                               "System.Xml.Linq",
                                               "System.Data.DataSetExtensions",
                                               "System.Data",
                                               "System.Xml"));

    conf.CsprojUserFile = new Configuration.CsprojUserFileSettings();
    conf.CsprojUserFile.StartAction = Configuration.CsprojUserFileSettings.StartActionSetting.Program;

    string quote = "\'"; // Use single quote that is cross platform safe
    conf.CsprojUserFile.StartArguments = $@"/sources(@{quote}{string.Join($"{quote},@{quote}", Path.Combine(Globals.SharpmakeRoot, "src/main.sharpmake.cs /diagnostics"))}{quote})";
    conf.CsprojUserFile.StartProgram = sharpmakeAppPath;
    conf.CsprojUserFile.WorkingDirectory = Directory.GetCurrentDirectory();

    conf.EventPostBuild.Add($"{sharpmakeAppPath} {$@"/sources(@{quote}{string.Join($"{quote},@{quote}", Path.Combine(Globals.SharpmakeRoot, "src/main.sharpmake.cs"))}{quote})"}");
  }
}

[Generate]
public class RexStandardLibraryExe : BaseProject
{
  public RexStandardLibraryExe() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "RexStdExe";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."
    SourceRootPath = Path.Combine(Globals.SourceRoot, "RexStdExe");

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);
    RexTarget ninjaTarget = new RexTarget(Platform.win64, DevEnv.ninja, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC | Compiler.Clang);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget, ninjaTarget);
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Exe;

    conf.add_dependency<RexStandardLibrary>(target);
  }
}

[Generate]
public class RexStandardLibraryTests : BaseProject
{
  public RexStandardLibraryTests() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "RexStdTest";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."
    SourceRootPath = Path.Combine(Globals.SourceRoot, "RexStdTest");

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);
    RexTarget ninjaTarget = new RexTarget(Platform.win64, DevEnv.ninja, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC | Compiler.Clang);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget, ninjaTarget);
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Exe;

    conf.Options.Remove(Options.Vc.Compiler.JumboBuild.Enable);
    conf.EventPostBuild.Clear();

    conf.add_dependency<RexStandardLibrary>(target);
  }
}

[Generate]
public class RexStandardLibrary : BaseProject
{
  public RexStandardLibrary() : base()
  {
    // The name of the project in Visual Studio. The default is the name of
    // the class, but you usually want to override that.
    Name = "RexStd";

    // The directory that contains the source code we want to build is the
    // same as this one. This string essentially means "the directory of
    // the script you're reading right now."
    SourceRootPath = Path.Combine(Globals.SourceRoot, "RexStd");

    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);
    RexTarget ninjaTarget = new RexTarget(Platform.win64, DevEnv.ninja, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC | Compiler.Clang);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget, ninjaTarget);
  }

  public override void Configure(RexConfiguration conf, RexTarget target)
  {
    base.Configure(conf, target);

    conf.Output = Configuration.OutputType.Lib;

    switch (conf.Platform)
    {
      case Platform.win32:
        conf.add_public_define("REX_PLATFORM_X86");
        break;
      case Platform.win64:
        conf.add_public_define("REX_PLATFORM_X64");
        break;
      default:
        break;
    }
  }
}

// Represents the solution that will be generated and that will contain the
// project with the sample code.
[Generate]
public class MainSolution : Solution
{
  public MainSolution() : base(typeof(RexTarget))
  {
    // The name of the solution.
    Name = "rex-standard-library";

    // As with the project, define which target this solution builds for.
    // It's usually the same thing.
    RexTarget vsTarget = new RexTarget(Platform.win64, DevEnv.vs2019, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC);
    RexTarget ninjaTarget = new RexTarget(Platform.win64, DevEnv.ninja, Config.debug | Config.debug_opt | Config.release, Compiler.MSVC | Compiler.Clang);

    // Specify the targets for which we want to generate a configuration for.
    AddTargets(vsTarget, ninjaTarget);
  }

  // Configure for all 4 generated targets. Note that the type of the
  // configuration object is of type Solution.Configuration this time.
  // (Instead of Project.Configuration.)
  [Configure]
  public void Configure(Configuration conf, RexTarget target)
  {
    // Puts the generated solution in the root folder.
    conf.SolutionPath = Globals.Root;

    // Adds the project described by BasicsProject into the solution.
    // Note that this is done in the configuration, so you can generate
    // solutions that contain different projects based on their target.
    //
    // You could, for example, exclude a project that only supports 64-bit
    // from the 32-bit targets.
    conf.AddProject<RexStandardLibraryExe>(target);
    conf.AddProject<RexStandardLibraryTests>(target);
  }
}

public static class Main
{
  private static bool MsvcInitialized = false;
  private static bool ClangInitialized = false;
  private static bool GccInitialized = false;
  private static bool NinjaInitialized = false;

  private static readonly string MsvcCompilerName = "cl.exe";
  private static readonly string ClangCompilerName = "clang.exe";
  private static readonly string GccCompilerName = "g++.exe";
  private static readonly string MsvcLinkerName = "link.exe";
  private static readonly string ClangLinkerName = "clang.exe";
  private static readonly string GccLinkerName = "g++.exe";

  private static readonly string MsvcArchiverName = "lib.exe";
  private static readonly string ClangArchiverName = "llvm-ar.exe";
  private static readonly string ClangRanLibName = "llvm-ranlib.exe";
  private static readonly string GccArchiverName = "ar.exe";

  const string NinjaName = "ninja.exe";

  [Sharpmake.Main]
  public static void SharpmakeMain(Arguments arguments)
  {
    Globals.Init();

    InitializeSharpmake();

    // Tells Sharpmake to generate the solution described by MainSolution.
    arguments.Generate<MainSolution>();
  }

  private static void InitializeSharpmake()
  {
    InitializeNinja();

    // Initialize Visual Studio settings
    KitsRootPaths.SetUseKitsRootForDevEnv(DevEnv.vs2019, KitsRootEnum.KitsRoot10, Options.Vc.General.WindowsTargetPlatformVersion.v10_0_19041_0);
  }

  private static void InitializeFromEnvPath()
  {
    string MsvcCompilerPath = "";
    string ClangCompilerPath = "";
    string GccCompilerPath = "";
    string MsvcLinkerPath = "";
    string ClangLinkerPath = "";
    string GccLinkerPath = "";

    string MsvcArchiver = "";
    string ClangArchiver = "";
    string ClangRanLib = "";
    string GccArchiver = "";

    string NinjaPath = "";

    var envPath = Environment.GetEnvironmentVariable("PATH");
    string[] paths = envPath.Split(';');

    foreach (var path in paths)
    {
      if (!Directory.Exists(path))
      {
        continue;
      }

      List<string> files = Directory.EnumerateFiles(path).ToList();

      foreach (string file in files)
      {
        string filename = Path.GetFileName(file);

        if (filename == MsvcCompilerName)
        {
          MsvcCompilerPath = file;
        }
        if (filename == ClangCompilerName)
        {
          ClangCompilerPath = file;
        }
        if (filename == GccCompilerName)
        {
          GccCompilerPath = file;
        }
        if (filename == MsvcLinkerName)
        {
          MsvcLinkerPath = file;
        }
        if (filename == ClangLinkerName)
        {
          ClangLinkerPath = file;
        }
        if (filename == GccLinkerName)
        {
          GccLinkerPath = file;
        }
        if (filename == MsvcArchiverName)
        {
          MsvcArchiver = file;
        }
        if (filename == ClangArchiverName)
        {
          ClangArchiver = file;
        }
        if (filename == ClangRanLibName)
        {
          ClangRanLib = file;
        }
        if (filename == GccArchiverName)
        {
          GccArchiver = file;
        }
        if (filename == NinjaName)
        {
          NinjaPath = file;
        }
      }
    }

    MsvcInitialized = SetCompilerPathsChecked(Compiler.MSVC, MsvcCompilerPath, MsvcLinkerPath, MsvcArchiver, "");
    ClangInitialized = SetCompilerPathsChecked(Compiler.Clang, ClangCompilerPath, ClangLinkerPath, ClangArchiver, ClangRanLib);
    GccInitialized = SetCompilerPathsChecked(Compiler.GCC, GccCompilerPath, GccLinkerPath, GccArchiver, "");

    if (string.IsNullOrEmpty(NinjaPath))
    {
      Util.LogWrite($"Ninja Path not found");
      NinjaInitialized = false;
    }
    else
    {
      KitsRootPaths.SetNinjaPath(NinjaPath);
      NinjaInitialized = true;
    }
  }

  private static void InitializeNinja()
  {
    // First look for the exeuctables in PATH env variable
    InitializeFromEnvPath();

    if (MsvcInitialized == false)
    {
      if (InitializeFromToolsPath(Compiler.MSVC, Path.Combine("msvc", "14.29.30133", "bin", "Hostx64", "x64"), MsvcCompilerName, MsvcLinkerName, MsvcArchiverName, "not used") == false)
      {
        throw new Error("Failed to find msvc path");
      }
    }
    if (ClangInitialized == false)
    {
      if (InitializeFromToolsPath(Compiler.Clang, Path.Combine("llvm", "bin"), ClangCompilerName, ClangLinkerName, ClangArchiverName, ClangRanLibName) == false)
      {
        throw new Error("Failed to find llvm path");
      }
    }
    if (NinjaInitialized == false)
    {
      string ninjaPath = Path.Combine(Globals.ToolsRoot, "ninja");
      if (Directory.Exists(ninjaPath) == false)
      {
        Util.LogWrite($"Error: ninja path '{ninjaPath}' does not exist");
        throw new Error("Failed to find ninja path");
      }
      else
      {
        KitsRootPaths.SetNinjaPath(ninjaPath);
      }
    }
  }

  private static bool InitializeFromToolsPath(Compiler compiler, string folderName, string compilerName, string linkerName, string archiverName, string ranlibName)
  {
    string path = Path.Combine(Globals.ToolsRoot, folderName);
    if (Directory.Exists(path) == false)
    {
      Util.LogWrite($"Error: {folderName} path '{path}' does not exist");
      return false;
    }

    string compilerPath = Path.Combine(path, compilerName);
    string linkerPath = Path.Combine(path, linkerName);
    string archiverPath = Path.Combine(path, archiverName);
    string ranLibPath = Path.Combine(path, ranlibName);

    KitsRootPaths.SetCompilerPaths(compiler, compilerPath, linkerPath, archiverPath, ranLibPath);
    return true;
  }
  private static bool SetCompilerPathsChecked(Compiler compiler, string compilerPath, string linkerPath, string archiverPath, string ranLibPath)
  {
    if (string.IsNullOrEmpty(compilerPath) || string.IsNullOrEmpty(linkerPath) || string.IsNullOrEmpty(archiverPath))
    {
      Util.LogWrite($"Warning: {compiler} paths not found:");
      if (string.IsNullOrEmpty(compilerPath))
        Util.LogWrite($"Warning: {compiler} Compiler Path not found");
      if (string.IsNullOrEmpty(linkerPath))
        Util.LogWrite($"Warning: {compiler} Linker Path not found");
      if (string.IsNullOrEmpty(archiverPath))
        Util.LogWrite($"Warning: {compiler} Archiver Path not found");
      if (compiler == Compiler.Clang)
      {
        if (string.IsNullOrEmpty(ranLibPath))
          Util.LogWrite($"Warning: {compiler} RanLib Path not found");
      }

      return false;
    }
    else
    {
      KitsRootPaths.SetCompilerPaths(compiler, compilerPath, linkerPath, archiverPath, ranLibPath);
      return true;
    }
  }
}