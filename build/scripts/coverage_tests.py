import os
from pathlib import Path
import required_tools
import util
import subprocess
import re
import diagnostics

def index_rawdata(rawdataPath):
  folder = Path(rawdataPath).parent
  output_path = os.path.join(folder, f"{Path(rawdataPath).stem}.profdata")
  llvm_profdata_path = required_tools.tool_paths["llvm_profdata_path"]
  os.system(f"{llvm_profdata_path} merge -sparse {rawdataPath} -o {output_path}")

  return output_path

def line_oriented_report_filename(profDataPath):
  return os.path.join(Path(profDataPath).parent, f"{Path(profDataPath).stem}_line.report")

def file_level_summary_filename(profDataPath):
  return os.path.join(Path(profDataPath).parent, f"{Path(profDataPath).stem}_file.report")

def create_line_oriented_report(programPath, profDataPath):
  llvm_cov_path = required_tools.tool_paths["llvm_cov_path"]
  log_file_path = line_oriented_report_filename(profDataPath)
  if os.path.exists(log_file_path):
    os.remove(log_file_path)

  f = open(log_file_path, "w")
  cmd = f"{llvm_cov_path} show {programPath} -instr-profile={profDataPath} >> {log_file_path}"
  f.write(f"# This file was generated by running the following command:\n")
  f.write(f"# {cmd}\n")
  f.close()
  os.system(cmd) # using >> is a hack to get the logs into a file, capturing stdout lines crashes llvm
  return log_file_path
  
def create_file_level_summary(programPath, profDataPath):
  llvm_cov_path = required_tools.tool_paths["llvm_cov_path"]
  log_file_path = file_level_summary_filename(profDataPath)
  if os.path.exists(log_file_path):
    os.remove(log_file_path)

  f = open(log_file_path, "w")
  cmd = f"{llvm_cov_path} report {programPath} -instr-profile={profDataPath} >> {log_file_path}"
  f.write(f"# This file was generated by running the following command:\n")
  f.write(f"# {cmd}\n")
  f.close()
  os.system(cmd) # using >> is a hack to get the logs into a file, capturing stdout lines crashes llvm
  return log_file_path

class CoverageCategory:
  def __init__(self, total, missed, cover):
    self._total : str = total   # total number of elements of the category
    self._missed : str = missed # missed number of elements of the category
    self._cover : str = cover  # percent of the category covered

  def coverage(self):
    if self._cover == '-': # no elements of category in file
      return 100
    else:
      return float(self._cover.strip('%'))

  def total_str(self):
    return f"total: {self._total}"

  def missed_str(self):
    return f"missed: {self._total}"

  def covered_str(self):
    return f"covered: {self._total}"

class FileSummary:
  def __init__(self, line : str):
    words = line.split()
    self._filename = words[0]
    self._regions_summary = CoverageCategory(words[1], words[2], words[3])    
    self._functions_summary = CoverageCategory(words[4], words[5], words[6])    
    self._lines_summary = CoverageCategory(words[7], words[8], words[9])    
    self._branches_summary = CoverageCategory(words[10], words[11], words[12])    

  def to_string(self):
    result = ""
    result += f"#################################"
    result += f"coverage for file: {self._filename}"
    result += f"REGIONS:"
    result += f"---------------------------------"
    result += self._regions_summary.total_str()
    result += self._regions_summary.missed_str()
    result += self._regions_summary.covered_str()
    result += f"FUNCTIONS:"
    result += f"---------------------------------"
    result += self._functions_summary.total_str()
    result += self._functions_summary.missed_str()
    result += self._functions_summary.covered_str()
    result += f"LINES:"
    result += f"---------------------------------"
    result += self._lines_summary.total_str()
    result += self._lines_summary.missed_str()
    result += self._lines_summary.covered_str()
    result += f"BRANCHES:"
    result += f"---------------------------------"
    result += self._branches_summary.total_str()
    result += self._branches_summary.missed_str()
    result += self._branches_summary.covered_str()

    return result

  def filename(self):
    return self._filename

  def coverage(self):
    res = 0
    res += self._regions_summary.coverage()
    res += self._functions_summary.coverage()
    res += self._lines_summary.coverage()
    res += self._branches_summary.coverage()
    return res / 4

def parse_file_summary(filepath):
  file = open(filepath, "r")

  # format of file summary file:
  # lines starting with '#' are comments
  # lines with only consisting of '-' are separators 
  
  # Column names:
  # Filename | Regions | Missed Regions | Cover | Functions | Missed Functions | Executed | Lines | Missed Lines | Cover | Branches | Missed Branches | Cover
  # <separator>
  # file 1
  # file 2
  # ...
  # <separator>
  # Total

  file_summaries : list[FileSummary] = []
  total_summary : FileSummary
  lines = file.readlines()
  column_names_processed = False
  for line in lines:
    if line.startswith('#'):
      continue

    if re.search(r'[^-]', line).start() >= 200: # report files use a lot of '-' tokens as separators
      column_names_processed = True
      continue

    # the column names are displayed first, only after that do the actual files get shown
    if column_names_processed == False:
      continue

    if line.split()[0] == "TOTAL":  # filename == TOTAL
      total_summary = FileSummary(line)
    else:
      file_summaries.append(FileSummary(line))

  result = 0

  for file_summary in file_summaries:
    if file_summary.coverage() != 100:
      result = 1
      diagnostics.log_err(f"File {file_summary.filename()} was not fully covered, please see below for more details")
      diagnostics.log_err(f"Alternatively, investigate the line coverage report file for this file")    
      diagnostics.log_err(f"This file is located at {Path(filepath).parent}")    

  if result != 0:
    diagnostics.log_err(f"Errors reported for file: {filepath}")

  return result
